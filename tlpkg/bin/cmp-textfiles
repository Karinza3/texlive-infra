#!/usr/bin/env perl
# $Id$
# Public domain.  Originally written 2008, Karl Berry.
# Compare two files for being "essentially" equivalent; see help msg below.
# 
# Used in the place and tlpkg-ctan-check scripts in TeX Live.

exit (&main ());

sub main {
  if (@ARGV != 2) {
    warn <<END_USAGE;
Usage: $0 FILE1 FILE2.
Compare as text files, ignoring line endings, blank lines, and %% lines.
Exit status is zero if the same, 1 if different, something else if trouble.
END_USAGE
    exit $ARGV[0] eq "--help" ? 0 : 2;
  }
  
  my $file1 = &read_file ($ARGV[0]);
  my $file2 = &read_file ($ARGV[1]);
  
  return $file1 eq $file2 ? 0 : 1;
}


# Return contents of FNAME as a string, converting both CR and CRLF to LF.
# 
# Also, annoyingly, ignore lines consisting only of "%%".  For an
# unknown reason, derived files on CTAN often contain these lines, while
# the same files regenerated by us do not.  CTAN's general policy is not
# to hold derived files, but there are too many exceptions and it is not
# worth the time to continually contact CTAN and authors.
# 
sub read_file {
  my ($fname) = @_;
  my $ret = "";
  
  open (my $FILE, $fname) || die "open($fname) failed: $!";
  while (<$FILE>) {
    s/\r\n?/\n/g;
    # ignoring blank lines causes problems because of the eol
    # conversions, e.g., in cbaccent.mf and jpsj/template.tex. sigh.
    next if /^\s*%%\s*$/; # ignore %% lines, see above.
    #warn "line is |$_|";
    $ret .= $_;
  }
  close ($FILE) || warn "close($fname) failed: $!";

  # if the file did not have a trailing newline, add one for purposes of
  # comparison, since it can slip in if we edit it, etc.
  $ret .= "\n" if substr ($ret, -1) ne "\n";
  
  return $ret;
}
